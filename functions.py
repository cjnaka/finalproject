import keys
from geopy.geocoders import Nominatim
import urllib.parse, urllib.request, urllib.error, json
import random
import os
#
#
#Grabbing the weather information for the specific location!!!!
#
#

weather_api_key = keys.weather_key

my_dir = os.path.dirname(__file__)
with open(os.path.join(my_dir, 'playlist_pool.json'),"r", encoding="utf-8") as f:
    playlist_pool = json.load(f)

def geocode(place):
    geocoder = Nominatim(user_agent="Learning Flask")
    location = geocoder.geocode(place)
    if location:
        return (location.latitude, location.longitude)
    else:
        return None

def get_weather(place):
    coordinates = geocode(place)
    if coordinates is None:
        return []

    lat, lon = coordinates

    try:
        parameters = {'lat': lat, 'lon': lon, 'appid': weather_api_key}
        paramstr = urllib.parse.urlencode(parameters)

        baseurl = 'http://api.openweathermap.org/data/2.5/weather?'
        weather_request = baseurl + paramstr
        weather_response_str = urllib.request.urlopen(weather_request).read()

        json_data = json.loads(weather_response_str)
        temperature_kelvin = json_data['main']['temp']

        temperature_fahrenheit = ((temperature_kelvin-273.15)*1.8) + 32
        weather_type = json_data['weather'][0]["main"]

        return temperature_fahrenheit, weather_type
    except Exception as e:
        print(f"Error retrieving weather data: {e}")
        return None

def determine_song(temp, type, num_songs):
    if temp is None or not type:
        return []

    type = type.lower()

    if temp < 32:
        temp_category = "freezing"
    elif temp < 50:
        temp_category = "cold"
    elif temp < 68:
        temp_category = "mild"
    elif temp < 84:
        temp_category = "warm"
    else:
        temp_category = "hot"

    key = None

    if type in ["clear", "clouds"]:
        key = f"{temp_category}_{type}"
    elif type == "thunderstorm":
        key = "stormy"
    elif type == "drizzle":
        key = "light"
    elif type == "rain":
        key = "rain"
    elif type == "snow":
        key = "peaceful"
    elif type == "atmosphere":
        key = "moody"

    songs = playlist_pool[key]
    return random.sample(songs, min(num_songs, len(songs)))

#
#
#Creating the Spotify playlist!!!!!!
#
#

def create_spotify_playlist(songs: list, playlist_name: str, client):
    api_endpoint = "https://api.spotify.com/v1"

    try:
        user_resp = client.get(f"{api_endpoint}/me")
        user_resp.raise_for_status()
        user_id = user_resp.json()["id"]
    except Exception as e:
        print(f"Error getting user info: {e}")
        return None

    try:
        create_resp = client.post(
            f"{api_endpoint}/users/{user_id}/playlists",
            json={
                "name": playlist_name,
                "public": True,
                "description": "Generated by Weatherbox"
            }
        )
        create_resp.raise_for_status()
        playlist_id = create_resp.json()["id"]
    except Exception as e:
        print(f"Error creating playlist: {e}")
        return None

    track_uris = []
    for song in songs:
        try:
            search_resp = client.get(f"{api_endpoint}/search",
                                     params = {"q": song, "type": "track", "limit": 1})
            search_resp.raise_for_status()
            results = search_resp.json()["tracks"]["items"]
            if results:
                track_uris.append(results[0]["uri"])
        except Exception as e:
            print(f"Error finding song '{song}': {e}")

    if not track_uris:
        print("No track URIs found.")
        return None

    try:
        add_resp = client.post(f"{api_endpoint}/playlists/{playlist_id}/tracks", json={"uris": track_uris})
        add_resp.raise_for_status()

        return playlist_id
    except Exception as e:
        print(f"Error adding tracks: {e}")
        return None
